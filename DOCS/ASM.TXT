

  FUNKTIONSPARAMETER

  - Die Parameter werden vor dem Call auf den
    Stack geworfen. Innerhalb der Funktion liegen
    die Parameter bei ss:[bp+4+Parameter], weil
    ältere Elemente auf der Plus-Seite von SP
    sind und weil IP und Stackframe zwischen der
    aktuellen Stackposition und den Parametern
    liegen. Daher die extra +4 in dem Term. Die
    Parameterposition hängt dann vom Offset in der
    Summe der Datentypen ab.

  LOKALE VARIABLEN

  - Die lokalen Variablen liegen, wie die Parameter
    auf dem Stack, werden aber nachträglich dort
    angelegt, quasi von überall innerhalb der Funktion.
    Ihr Offset liegt also grundsätzlich auf der Minus-
    Seite von ss:[bp].

  - Da die lokalen Variablen auch Arrays enthalten
    können und grundsätzlich mit aufsteigenden
    Adressen gearbeitet werden soll, reicht es nicht,
    absteigende Positionen für die lokalen Variablen
    aufzusummieren, da die Reihenfolge dabei von
    rechts nach links laufen würde. Alternativ wird
    ermittelt, wieviele Variablen wieviel Platz
    benötigen und dieser Wert dann von den aufsummierten
    und von links nach rechts verlaufenden Offsets
    abgezogen, um in den negativen Bereich zu gelangen.
    Es wird also von links nach rechts aufsummiert,
    und dann die Gesamtsumme von jedem Element abgezogen,
    was auch getrennt passieren kann. Bei der Definition
    wird die Summe weiter erhöht, die effektive Adresse
    wird allerdings erst errechnet, wenn ein Zugriff
    erfolgt. Bei dieser Vorgehensweise ist es allerdings
    notwendig, daß alle lokalen Variablen vollständig
    'forward' definiert werden, d.h. alle Variablen
    müssen fertig definiert worden sein, bevor der erste
    Zugriff auf eine davon erfolgt. Das erspart das
    über-patchen aller Zugriffe am Ende einer Funktion
    und der Assembler kann mit einer Hilfsliste weniger
    auskommen.

  - Die aktuelle Stackposition enthält IP. Ich müßte +2
    addieren, damit ich IP überspringen kann. Nun kommt
    noch der alte übergeordnete Stackframe hinzu, also
    nochmal +2, macht zusammen +4. Jetzt liege ich bei
    den Parametern. Die sind hier aber nicht gefragt,
    sondern ich will zu den lokalen Variablen.
    Gibt es nur 1 Byte, dann muß ich -1+0 rechnen, um
    zu der Adresse zu kommen: ss:[bp-1+0].
    Gibt es zwei Bytes, dann muß ich -2+0 für das erste
    und -2+1 für das zweite rechnen.
    Bei 3 DWORDS müßte ich -12+0 für das erste, -12+4
    für das zweite und -12+8 für das letzte rechnen,
    wobei -12+8,9,10,11 die einzelnen Bytes sind, die
    in gewohnt aufsteigender Reihenfolge vorliegen.
    Ich erreiche nie IP, weil IP wäre ss:[bp-12+12] in
    dem Beispiel.

  - Der alte Stackframe muß in jeder Funktion gesichert
    werden und SP muß auf eine neue Stackposition verschoben
    werden, damit die PUSH/POP-Befehle weiterhin funktionieren.
    Das kann jedoch nur geschehen, nachdem alle Variablen
    definiert worden sind. Daher wird das Patchlabel für
    SUB SP,XXXX zwischengespeichert und am Ende der Funktion
    in den Binärcode gepatcht.

  - Eine wesentliche Optimierung des Assemblers besteht
    darin, zu bemerken, wenn derselbe Zeiger mehrfach
    verwendet wird. In dem Fall müßte EDI nicht ständig
    neu mit der Adresse beladen werden. Es könnten
    sogar mehrere Strukturelemente unterschiedlichen
    Offsets nacheinander berechnet werden, ohne daß EDI
    jedesmal aus der Zeigervariablen neu geladen werden muß.






  OPTIMIERUNGEN



  ZEIGEROPTIMIERUNG

  Wird ein Zeiger benutzt, wird seine <Variable> global
  gespeichert. Wird derselbe Zeiger h„ufiger verwendet,
  muá EDI nicht immer wieder geladen werden.

  Dieser Fall gilt allerdings nur, solange dieselbe <Variable>
  nicht zwischendurch das L-Value ist. In dem Falle wrde
  der Zwischenspeicher gel”scht und EDI bei Verwendung des
  Zeigers erneut geladen, um garantiert frische Daten zu
  haben.





  DISPLACEMENT-OPTIMIERUNG

  Fast alle Befehle verwenden ein 4-Byte-Displacement.
  Bei Variablen w„re dieses immer Null und beim ersten
  Element einer Struktur ebenfalls.

  Die CPU bietet fr viele Befehle krzere Schreibweisen
  an, wenn das Displacement nur ein Byte ist.

  Im Grunde geschieht das ber die MOD-Bits des ModRM-Bytes:
  MOD=10 bedeutet 16-Bit-Displacement und MOD=01 bedeutet
  8-Bit Displacement.

  Einen SS:[BP]-Modus gibt es nicht, da Reg=110 und Mod=00
  direkte Adressierung bedeutet.

  Glcklicherweise kommt BP+00 nicht vor, da lokales VOR
  und Parameter HINTER BP liegen, Schwein gehabt^^


  Zur Disp-Optimierung geh”ren sicherlich auch die
  LadeZeiger-Befehle <MOV EDI,DS:[ESI+Disp]>, wie auch
  <MOV EDI,SS:[BP+Disp]>.



    